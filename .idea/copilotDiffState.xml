<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/client/client.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/client.go" />
              <option name="originalContent" value="package client&#10;&#10;import (&#10;&#9;&quot;ayode.org/visor/config&quot;&#10;&#9;&quot;ayode.org/visor/validations&quot;&#10;&#9;&quot;bytes&quot;&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;golang.org/x/net/publicsuffix&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;log/slog&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;net/http/cookiejar&quot;&#10;&#9;&quot;net/url&quot;&#10;&#9;&quot;reflect&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;type Client struct {&#10;&#9;cfg config.Config&#10;&#9;jar *cookiejar.Jar&#10;&#9;u   *url.URL&#10;}&#10;&#10;func New(cfg config.Config) (*Client, error) {&#10;&#9;jar, err := cookiejar.New(&amp;cookiejar.Options{&#10;&#9;&#9;PublicSuffixList: publicsuffix.List,&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to initialize the cookiejar&quot;)&#10;&#9;}&#10;&#10;&#9;u, err := url.Parse(cfg.Root)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to parse the root URL&quot;)&#10;&#9;}&#10;&#10;&#9;c := Client{&#10;&#9;&#9;cfg,&#10;&#9;&#9;jar,&#10;&#9;&#9;u,&#10;&#9;}&#10;&#10;&#9;c.SetCookies(c.cfg.Jar)&#10;&#9;return &amp;c, nil&#10;}&#10;&#10;func (c *Client) sendRequest(req *http.Request) (*http.Response, io.Reader, error) {&#10;&#9;client := &amp;http.Client{&#10;&#9;&#9;Jar: c.jar,&#10;&#9;}&#10;&#9;resp, err := client.Do(req)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, nil, err&#10;&#9;}&#10;&#10;&#9;defer resp.Body.Close()&#10;&#10;&#9;// Same as io.ReadAll(), but has less allocations therefore better performance&#10;&#9;buf := &amp;bytes.Buffer{}&#10;&#9;_, err = io.Copy(buf, resp.Body)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, nil, err&#10;&#9;}&#10;&#10;&#9;return resp, buf, nil&#10;}&#10;&#10;func validateStatus(endpoint *config.Endpoint, statusCode uint16) error {&#10;&#9;if endpoint.AcceptStatus == nil || len(endpoint.AcceptStatus) == 0 {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;for _, currStatus := range endpoint.AcceptStatus {&#10;&#9;&#9;if currStatus == statusCode {&#10;&#9;&#9;&#9;return nil&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return fmt.Errorf(&quot;invalid HTTP status recieved: %d&quot;, statusCode)&#10;}&#10;&#10;func isJSONBody(body interface{}) bool {&#10;&#9;switch body.(type) {&#10;&#9;case map[string]interface{}, []interface{}:&#10;&#9;&#9;return true&#10;&#9;default:&#10;&#9;&#9;// Check for struct types (since it technically doesn't have an explicit type in the Golang system)&#10;&#9;&#9;t := reflect.TypeOf(body)&#10;&#9;&#9;return t != nil &amp;&amp; t.Kind() == reflect.Struct&#10;&#9;}&#10;}&#10;&#10;func marshalReqBody(body interface{}, buffer *io.Reader) error {&#10;&#9;if body != nil {&#10;&#9;&#9;jsonBody, err := json.Marshal(body)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;could not marshal request body: %w&quot;, err)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;*buffer = bytes.NewBuffer(jsonBody)&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;func (c *Client) Execute() {&#10;&#9;for _, endpoint := range c.cfg.Endpoints {&#10;&#9;&#9;logger := slog.With(&quot;taskName&quot;, endpoint.Name, &quot;path&quot;, endpoint.Path, &quot;method&quot;, endpoint.Method)&#10;&#10;&#9;&#9;var reqBuff io.Reader&#10;&#9;&#9;err := marshalReqBody(endpoint.Body, &amp;reqBuff)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;logger.Error(&quot;Failed to marshal request body:&quot; + err.Error())&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;reqObj, err := http.NewRequest(endpoint.Method, c.cfg.Root+endpoint.Path, reqBuff)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;logger.Error(&quot;Failed to create request: &quot; + err.Error())&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if isJSONBody(endpoint.Body) {&#10;&#9;&#9;&#9;reqObj.Header.Set(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;reqObj.Header.Set(&quot;Content-Type&quot;, &quot;text/plain&quot;)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Add custom headers (config-level)&#10;&#9;&#9;for _, header := range c.cfg.Headers {&#10;&#9;&#9;&#9;reqObj.Header.Set(header.Key, header.Value)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Add custom headers (request-level)&#10;&#9;&#9;for _, header := range endpoint.Headers {&#10;&#9;&#9;&#9;reqObj.Header.Set(header.Key, header.Value)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Add cookies from jar (config-level)&#10;&#9;&#9;c.SetCookies(endpoint.Jar)&#10;&#10;&#9;&#9;// Add cookies (request-level)&#10;&#9;&#9;c.SetReqCookies(reqObj, endpoint.Cookies)&#10;&#10;&#9;&#9;start := time.Now()&#10;&#9;&#9;resp, respBody, err := c.sendRequest(reqObj)&#10;&#9;&#9;elapsed := time.Now().Sub(start)&#10;&#10;&#9;&#9;respString, err := io.ReadAll(respBody)&#10;&#9;&#9;println(string(respString))&#10;&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;logger.Error(&quot;Failed to send request: &quot; + err.Error())&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check if response code is the expected value&#10;&#9;&#9;err = validateStatus(&amp;endpoint, uint16(resp.StatusCode))&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;logger.Error(err.Error())&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;if endpoint.Schema != &quot;&quot; {&#10;&#9;&#9;&#9;err = validations.ValidateSchemaFromPath(respBody, endpoint.Schema)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;logger.Error(&quot;Failed to validate response body: &quot; + err.Error())&#10;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;}&#10;&#9;&#9;logger.With(&quot;elapsed&quot;, elapsed).Info(&quot;Task Succeeded&quot;)&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package client&#10;&#10;import (&#10;&#9;&quot;ayode.org/visor/config&quot;&#10;&#9;&quot;ayode.org/visor/validations&quot;&#10;&#9;&quot;bytes&quot;&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;golang.org/x/net/publicsuffix&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;log/slog&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;net/http/cookiejar&quot;&#10;&#9;&quot;net/url&quot;&#10;&#9;&quot;reflect&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;type Client struct {&#10;&#9;cfg config.Config&#10;&#9;jar *cookiejar.Jar&#10;&#9;u   *url.URL&#10;}&#10;&#10;func New(cfg config.Config) (*Client, error) {&#10;&#9;jar, err := cookiejar.New(&amp;cookiejar.Options{&#10;&#9;&#9;PublicSuffixList: publicsuffix.List,&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to initialize the cookiejar&quot;)&#10;&#9;}&#10;&#10;&#9;u, err := url.Parse(cfg.Root)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to parse the root URL&quot;)&#10;&#9;}&#10;&#10;&#9;c := Client{&#10;&#9;&#9;cfg,&#10;&#9;&#9;jar,&#10;&#9;&#9;u,&#10;&#9;}&#10;&#10;&#9;c.SetCookies(c.cfg.Jar)&#10;&#9;return &amp;c, nil&#10;}&#10;&#10;func (c *Client) sendRequest(req *http.Request) (*http.Response, io.Reader, error) {&#10;&#9;client := &amp;http.Client{&#10;&#9;&#9;Jar: c.jar,&#10;&#9;}&#10;&#9;resp, err := client.Do(req)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, nil, err&#10;&#9;}&#10;&#10;&#9;defer resp.Body.Close()&#10;&#10;&#9;// Same as io.ReadAll(), but has less allocations therefore better performance&#10;&#9;buf := &amp;bytes.Buffer{}&#10;&#9;_, err = io.Copy(buf, resp.Body)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, nil, err&#10;&#9;}&#10;&#10;&#9;return resp, buf, nil&#10;}&#10;&#10;func validateStatus(endpoint *config.Endpoint, statusCode uint16) error {&#10;&#9;if endpoint.AcceptStatus == nil || len(endpoint.AcceptStatus) == 0 {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;for _, currStatus := range endpoint.AcceptStatus {&#10;&#9;&#9;if currStatus == statusCode {&#10;&#9;&#9;&#9;return nil&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return fmt.Errorf(&quot;invalid HTTP status recieved: %d&quot;, statusCode)&#10;}&#10;&#10;func isJSONBody(body interface{}) bool {&#10;&#9;switch body.(type) {&#10;&#9;case map[string]interface{}, []interface{}:&#10;&#9;&#9;return true&#10;&#9;default:&#10;&#9;&#9;// Check for struct types (since it technically doesn't have an explicit type in the Golang system)&#10;&#9;&#9;t := reflect.TypeOf(body)&#10;&#9;&#9;return t != nil &amp;&amp; t.Kind() == reflect.Struct&#10;&#9;}&#10;}&#10;&#10;func marshalReqBody(body interface{}, buffer *io.Reader) error {&#10;&#9;if body != nil {&#10;&#9;&#9;jsonBody, err := json.Marshal(body)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;could not marshal request body: %w&quot;, err)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;*buffer = bytes.NewBuffer(jsonBody)&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;func (c *Client) Execute() {&#10;&#9;for _, endpoint := range c.cfg.Endpoints {&#10;&#9;&#9;logger := slog.With(&quot;taskName&quot;, endpoint.Name, &quot;path&quot;, endpoint.Path, &quot;method&quot;, endpoint.Method)&#10;&#10;&#9;&#9;var reqBuff io.Reader&#10;&#9;&#9;err := marshalReqBody(endpoint.Body, &amp;reqBuff)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;logger.Error(&quot;Failed to marshal request body:&quot; + err.Error())&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;reqObj, err := http.NewRequest(endpoint.Method, c.cfg.Root+endpoint.Path, reqBuff)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;logger.Error(&quot;Failed to create request: &quot; + err.Error())&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if isJSONBody(endpoint.Body) {&#10;&#9;&#9;&#9;reqObj.Header.Set(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;reqObj.Header.Set(&quot;Content-Type&quot;, &quot;text/plain&quot;)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Add custom headers (config-level)&#10;&#9;&#9;for _, header := range c.cfg.Headers {&#10;&#9;&#9;&#9;reqObj.Header.Set(header.Key, header.Value)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Add custom headers (request-level)&#10;&#9;&#9;for _, header := range endpoint.Headers {&#10;&#9;&#9;&#9;reqObj.Header.Set(header.Key, header.Value)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Add cookies from jar (config-level)&#10;&#9;&#9;c.SetCookies(endpoint.Jar)&#10;&#10;&#9;&#9;// Add cookies (request-level)&#10;&#9;&#9;c.SetReqCookies(reqObj, endpoint.Cookies)&#10;&#10;&#9;&#9;start := time.Now()&#10;&#9;&#9;resp, respBody, err := c.sendRequest(reqObj)&#10;&#9;&#9;elapsed := time.Now().Sub(start)&#10;&#10;&#9;&#9;respString, err := io.ReadAll(respBody)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;logger.Error(&quot;Failed to read response body: &quot; + err.Error())&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;println(string(respString))&#10;&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;logger.Error(&quot;Failed to send request: &quot; + err.Error())&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check if response code is the expected value&#10;&#9;&#9;err = validateStatus(&amp;endpoint, uint16(resp.StatusCode))&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;logger.Error(err.Error())&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;if endpoint.Schema != &quot;&quot; {&#10;&#9;&#9;&#9;// Create a new reader from the response bytes for validation&#10;&#9;&#9;&#9;respReader := bytes.NewReader(respString)&#10;&#9;&#9;&#9;err = validations.ValidateSchemaFromPath(respReader, endpoint.Schema)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;logger.Error(&quot;Failed to validate response body: &quot; + err.Error())&#10;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;}&#10;&#9;&#9;logger.With(&quot;elapsed&quot;, elapsed).Info(&quot;Task Succeeded&quot;)&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>